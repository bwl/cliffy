# Next Session Prompt

Read these files in order to prepare for implementing streaming tool traces: (1) `docs/observability/current-state.md` to understand what infrastructure exists and what's missing, (2) `docs/observability/streaming-architecture.md` to understand why streaming is the recommended approach over post-execution display, and (3) `docs/observability/implementation-guide.md` for step-by-step instructions across 4 phases. The key insight is that cliffy already has streaming architecture (`agent.Run()` returns `<-chan AgentEvent`) but only emits one final event - we need to pass the event channel through context at `internal/llm/agent/agent.go:296` and emit tool trace events after tool execution at `agent.go:573`, then update `internal/volley/scheduler.go:207-256` to process all events (not just the final one), and finally add `ToolExecuted()` method to `internal/volley/progress.go` to display formatted traces using the existing `internal/output/formatter.go`. Total effort is 4-6 hours across 3 phases with testing checkpoints after each phase, and the end result is real-time tool traces like `[TOOL] read: src/main.go (890 lines, 35KB) â€” 0.8s` appearing as tools execute.
